<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #008000; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */

</style>
</head>
<body>
<div class="document">


<div class="section" id="the-easiest-command-line-arguments-parser-in-the-python-world">
<h1>The easiest command line arguments parser in the Python world</h1>
<p>Today I want to announce to the general public the birth of my latest
project, which aims to be the easiest command line arguments
parser in the Python world: <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a>.</p>
<p><a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> is designed to be <a class="reference external" href="http://www.welton.it/articles/scalable_systems">downwardly scalable</a>, i.e. to be trivially simple
to use for trivial use cases, while being surprisingly scalable upwards
for less trivial use cases. Still, <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> is not intended to
be an industrial strength command line parsing module. Its
capabilities are limited by design. If you need more power, by all means
use the parsing modules in the standard library. Still, I have been using
Python for 8 years and never once I had to use the full power of the
standard library modules.</p>
<p>Actually I am prettu much convinced that features provided by <tt class="docutils literal">plac</tt>
aee more than enough for 99.9% of the typical use cases of a scripter
working in a Unix-like environment. I am targetting here programmers,
sysadmins, scientists and in general people writing throw-away scripts
for themselves, choosing to use a command line interface because it is
the quick and simple. Such users are not interested in features,
they just want to be able to write a simple command line tool from a
simple specification, not to build a command line parser by
hand. Unfortunately, the current modules in the standard library
forces them to go the hard way. They are designed to implement
power user tools for programmers or system administrators, and
they have a non-trivial learning curve.</p>
<p>This is why, even  if there is no want of command line arguments
parsers in Python world, sometime like <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> was still lacking.</p>
<p>The standard library alone contains three different modules for the
parsing of command line options: <a class="reference external" href="http://docs.python.org/library/getopt.html">getopt</a> (from the stone age),
<a class="reference external" href="http://docs.python.org/library/optparse.html">optparse</a> (from Python 2.3) and <a class="reference external" href="http://argparse.googlecode.com">argparse</a> (from Python 2.7).  All of
them are quite powerful and especially <a class="reference external" href="http://argparse.googlecode.com">argparse</a> is an industrial
strength solution; <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> is just a nice and simple wrapper over
<a class="reference external" href="http://argparse.googlecode.com">argparse</a>, hiding most of the complexity while retaining most of
the power.</p>
</div>
<div class="section" id="the-importance-of-scaling-down">
<h1>The importance of scaling down</h1>
<p>An ex-coworket of mine, David Welton, once wrote a nice article about
the importance of <a class="reference external" href="http://www.welton.it/articles/scalable_systems">scaling down</a>: most people are concerned with the
possibility of scaling up, but we should also be concerned with the
issue of scaling down: in other worlds, simple things should be kept
simple. To be concrete, let me start with the simplest possible
thing: a script that takes a single argument and does something to it.
It cannot get more trivial than that (discarding the possibility of
a script without command line arguments, where there is nothing to parse),
nevertheless it is a use case <em>extremely important</em>:
I need to write scripts like that nearly every day, I wrote hundreds
of them in the last few years and I have never been happy. Here is
a typical example:</p>
<blockquote>
<pre class="literal-block">
def main(dsn):
    &quot;Do something with the database&quot;
    print(dsn)

if __name__ == '__main__':
    import sys
    n = len(sys.argv[1:])
    if n == 0:
        sys.exit('usage: python %s dsn' % sys.argv[0])
    elif n == 1:
        main(sys.argv[1])
    else:
        sys.exit('Unrecognized arguments: %s' % ' '.join(sys.argv[2:]))

</pre>
</blockquote>
<p>As you see the whole <tt class="docutils literal">if __name__ == '__main__'</tt> block (10 lines
counting an empty line) is essentially boilerplate that should not exists.
Actually I think the Python language should recognize the
main function and perform trivial arguments parsing behind the
scenes; unfortunaly this is unlikely to happen. Therefore I have
been writing boilerplate like this for years, and every time
I <em>hate</em> having to check for the <tt class="docutils literal">IndexError</tt> by hand, and I hate having
to write always the same usage message. The purpose of using a
scripting language is convenience and trivial things should be
trivial. Unfortunately the standard library modules do not help
for this use case, which may be trivial, but it is still
incredibly common. Using <a class="reference external" href="http://docs.python.org/library/getopt.html">getopt</a> and <a class="reference external" href="http://docs.python.org/library/optparse.html">optparse</a> does not help,
since they are intended to manage options and not positional arguments;
the <a class="reference external" href="http://argparse.googlecode.com">argparse</a> module helps a bit and it is able to reduce the
boilerplate from 10 lines to 7 lines:</p>
<blockquote>
<pre class="literal-block">
def main(dsn):
    &quot;Do something on the database&quot;
    print(dsn)

if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument('dsn')
    arg = p.parse_args()
    main(arg.dsn)

</pre>
</blockquote>
<p>However saving a three lines does not justify introducing the external
dependency (most people will not switch Python 2.7, currenctly in beta
for many years).
Moreover, it just feels too complex to instantiate a class and to
define a parser by hand for such a trivial task.</p>
<p>The <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> module works pretty well when scaling down, and it is able
to reduce the ten lines of boiler plate to two lines. With the
<a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> module all you need to write is</p>
<blockquote>
<pre class="literal-block">
def main(dsn):
    &quot;Do something with the database&quot;
    print(dsn)

if __name__ == '__main__':
    import plac; plac.call(main)

</pre>
</blockquote>
<p>As an additional bonus she <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> module automatically recognizes the help flag:</p>
<blockquote>
# python example1.py -h</blockquote>
<p>This is only the tip of the iceberg, as you will see.</p>
</div>
<div class="section" id="optional-arguments">
<h1>Optional arguments</h1>
<p>I have encountered this use case at work hundreds of times:</p>
<blockquote>
<pre class="literal-block">
def main(dsn):
    &quot;Do something on the database&quot;
    print(dsn)

if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument('dsn')
    arg = p.parse_args()
    main(arg.dsn)

</pre>
</blockquote>
<p>9 lines of boilerplate are removed.</p>
<p>Finally, often you want to pass a variable number of arguments to
your command line script. Here is an example, a script which runs
on the database a series of .sql scripts:</p>
<blockquote>
<pre class="literal-block">
from datetime import datetime

def main(dsn, *scripts):
    &quot;Run the given scripts on the database&quot;
    for script in scripts:
        print('executing %s' % script)

if __name__ == '__main__':
    if len(sys.argv) &lt; 2:
        sys.exit('usage: python %s dsn script.sql ...' % sys.argv[0])
    main(sys.argv[1:])

</pre>
</blockquote>
<p>Using <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a>, you can just replace the <tt class="docutils literal">__main__</tt> block with the usual
<tt class="docutils literal">import plac; plac.call(main)</tt>. The importanting is that you get a
much nicer usage message:</p>
<pre class="literal-block">
usage: example7.py [-h] dsn [scripts [scripts ...]]

positional arguments:
  dsn
  scripts

optional arguments:
  -h, --help  show this help message and exit
</pre>
</div>
<div class="section" id="options-and-flags">
<h1>Options and flags</h1>
<p>It is surprising how little command line scripts with options
I have written over the years (probably less than a hundred),
compared to the number of scripts with positional arguments
(I certainly have written more than a thousand of them).
Still, this use case is quite common and cannot be neglected.
The standard library modules (all of them) are quite verbose
when it comes to specifying the options and frankly I have
never used them directly. Instead, I have always relied on
an old recipe of mine, the <a class="reference external" href="http://code.activestate.com/recipes/278844-parsing-the-command-line/">optionparse</a> recipe, which provides a
convenient wrapper over <a class="reference external" href="http://code.activestate.com/recipes/278844-parsing-the-command-line/">optionparse</a> or I have just performed the
parsing by hand in the simplest cases.</p>
<p><a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> is inspired to the <a class="reference external" href="http://code.activestate.com/recipes/278844-parsing-the-command-line/">optionparse</a> recipe, in the sense that
it delivers the programmer from the burden of writing the
parser for the options by hand, but is less of a hack: instead
of extracting the parser from the docstring of the module, it
extracts it from the signature of the <tt class="docutils literal">main</tt> function.</p>
<p>The idea is to leverage on the <cite>function annotations</cite> concept, a new
feature of Python 3. An example is worth a thousand words, so here
it is:</p>
<blockquote>
<pre class="literal-block">
def main(command: (&quot;SQL query&quot;, 'option-c'), dsn):
    if command:
        print('executing %s on %s' % (command, dsn))

if __name__ == '__main__':
    import plac; plac.call(main)

</pre>
</blockquote>
<p>As you see, the argument <tt class="docutils literal">command</tt> has been annotated with the
tuple <tt class="docutils literal">(&quot;SQL query&quot;, <span class="pre">'option-c')</span></tt>: the first string is the
help string which will appear in the usage message, whereas the
second string tells <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> that <tt class="docutils literal">command</tt> is an option and that
it can be abbreviated with the letter <tt class="docutils literal">c</tt>. Of course, it also
possible to use the long option format, by prefixing the option
with <tt class="docutils literal"><span class="pre">--command=</span></tt>. The resulting usage message is the following:</p>
<pre class="literal-block">
$ python3 example8.py -h
usage: example8.py [-h] [-c COMMAND] dsn

positional arguments:
  dsn

optional arguments:
  -h, --help            show this help message and exit
  -c COMMAND, --command COMMAND
                        SQL query
</pre>
<p>Here are two examples of usage:</p>
<pre class="literal-block">
$ python3 example8.py -c&quot;select * from table&quot; dsn
executing select * from table on dsn

$ python3 example8.py --command=&quot;select * from table&quot; dsn
executing select * from table on dsn
</pre>
<p>Notice that if the option is not passed, the variable <tt class="docutils literal">command</tt>
will get the value <tt class="docutils literal">None</tt>.</p>
<p>Even positional argument can be annotated, but it makes no sense to
specify the &quot;option-c&quot; string, so you can skip it and write:</p>
<pre class="literal-block">
def main(command: (&quot;SQL query&quot;, 'option-c'), dsn: (&quot;Database dsn&quot;,)):
    ...
</pre>
<p>Alternatively, you can write <tt class="docutils literal">(&quot;Database dsn&quot;, None)</tt>. In both cases
the usage message now will show a nice help string on the right hand side
of the <tt class="docutils literal">dsn</tt> positional argument. varargs (starred-arguments) can also
be annotated:</p>
<pre class="literal-block">
def main(dsn: (&quot;Database dsn&quot;,), *scripts: (&quot;SQL scripts&quot;,)):
    ...
</pre>
<p>is a valid signature for <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a>, which will recognize the help strings
for both <tt class="docutils literal">dsn</tt> and <tt class="docutils literal">scripts</tt>.</p>
<p><a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> also recognizes flags, i.e. boolean options which are
True if they are passed to the command line and False if they are absent.
Here is an example:</p>
<pre class="literal-block">
$ python3 example9.py -v dsn
connecting to dsn
</pre>
<p>For consistency with the way the usage message is printed, I suggest to
follow the FOP convention: in the <tt class="docutils literal">main</tt> function write first
the flag arguments, then the option arguments and finally the positional
arguments. This is a convention and you are not forced to use it, but
it makes sense to put the position arguments at the end, since they
may be default arguments and varargs. In this document I will always use
the FOP convention.</p>
</div>
<div class="section" id="plac-is-also-for-people-not-using-python-3">
<h1>plac is also for people not using Python 3</h1>
<p>I do not use Python 3. At work we are just starting to think about
migrating to Python 2.6. I think it will take years before we even
think to migrate to Python 3. I am pretty much sure most Pythonistas
are in the same situation. Therefore <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a> provides a way to work
with function annotations even in Python 2.X (including Python 2.3).
There is no magic involved; you just need to add the annotations
by hand. For instance</p>
<pre class="literal-block">
def main(dsn: (&quot;Database dsn&quot;,), *scripts: (&quot;SQL scripts&quot;,)):
</pre>
<p>becomes:</p>
<pre class="literal-block">
def main(dsn, *scripts):
    ...
main.__annotations__ = dict(
dsn= (&quot;Database dsn&quot;,),
scripts=(&quot;SQL scripts&quot;,))
</pre>
<p>One should be careful to much the keys of the annotations dictionary
with the names of the arguments in the annotated function; for lazy
people with Python 2.4 available the simplest way is to use the
<tt class="docutils literal">plac.annotations</tt> decorator that performs the check for you.</p>
<pre class="literal-block">
&#64;annotations(
dsn= (&quot;Database dsn&quot;,),
scripts=(&quot;SQL scripts&quot;,))
def main(dsn, *scripts):
    ...
</pre>
<p>In the rest of this article I will assume that you are using Python 2.X with
X &gt;= 4 and I will use the <tt class="docutils literal">plac.annotations</tt> decorator.</p>
</div>
<div class="section" id="advanced-usage">
<h1>Advanced usage</h1>
<p>One of the goals of plac is to have a learning curve of <em>minutes</em>, compared
to the learning curve of <em>hours</em> of <a class="reference external" href="http://argparse.googlecode.com">argparse</a>. That does not mean
that I have removed all the advanced features of <a class="reference external" href="http://argparse.googlecode.com">argparse</a>. Actually
a lot of <a class="reference external" href="http://argparse.googlecode.com">argparse</a> power persists in <a class="reference external" href="http://www.welton.it/articles/scalable_systems">plac</a>: in particular, the
<tt class="docutils literal">type</tt>, <tt class="docutils literal">choices</tt> and <tt class="docutils literal">metavar</tt> concepts are there.
Here is an example showing all of them:</p>
<blockquote>
<pre class="literal-block">
import plac

&#64;plac.annotations(
operator=(&quot;The name of an operator&quot;, None, str, ['add', 'mul']),
numbers=(&quot;A number&quot;, None, float, None, &quot;n&quot;))
def main(operator, *numbers):
    op = getattr(float, '__%s__' % operator)
    result = dict(add=0.0, mul=1.0)[operator]
    for n in numbers:
        result = op(result, n)
    print(result)

if __name__ == '__main__':
    plac.call(main)

</pre>
</blockquote>
<p>Let me begin by discussing the <tt class="docutils literal">type</tt> feature: given any callable
taking a string in input a returning any Python object, it is possible
to automagically convert the parsed arguments with the callable, simply
by listing it in the annotation</p>
</div>
</div>
</body>
</html>
